// TS3Client - A free TeamSpeak3 client implementation
// Copyright (C) 2017  TS3Client contributors
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the Open Software License v. 3.0
//
// You should have received a copy of the Open Software License along with this
// program. If not, see <https://opensource.org/licenses/OSL-3.0>.

<#@ output extension=".cs" #>
<#@ template debug="true" hostSpecific="true" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#= "// *** DO NOT EDIT THIS FILE, IT HAS BEEN AUTO-GENERATED ***" #>

namespace TS3Client.Messages
{
	using System;
	using Commands;
	using ClientUidT = System.String;
	using ClientDbIdT = System.UInt64;
	using ClientIdT = System.UInt16;
	using ChannelIdT = System.UInt64;
	using ServerGroupIdT = System.UInt64;
	using ChannelGroupIdT = System.UInt64;
	using TimeSpanSecondsT = System.TimeSpan;
	using TimeSpanMillisecT = System.TimeSpan;

<#
	string declFilePath = Host.ResolvePath("MessageDeclarations.txt");
	string[] declLines = File.ReadAllLines(declFilePath);
	
	var fldDict = new Dictionary<string, GenField>();
	var msgDict = new Dictionary<string, GenMsg>();
	var ntfyDict = new Dictionary<string, GenNotify>();
	var convDict = new Dictionary<string, string>();
	
	foreach(var line in declLines)
	{
		if(string.IsNullOrWhiteSpace(line))
			continue;

		var parts = line.Split(new [] {':'}, 2);
		if(parts.Length < 2 || string.IsNullOrWhiteSpace(parts[0]))
			continue;

		parts[0] = parts[0].Trim().ToUpper();
		if(parts[0] == "MSG")
		{
			var param = parts[1].Replace(" ", "").Split(',');
			if(param.Length < 2) { this.Write("#warning Invalid MSG: " + line); continue; }
			msgDict.Add(param[0], new GenMsg { className=param[0], ntfyName=param[1] } );

			bool isNotify = !string.IsNullOrEmpty(param[1]);
			bool isResponse = string.IsNullOrEmpty(param[1]) || param[1].StartsWith("+");
			GenNotify genNotify = null;
			if(isNotify)
			{
				genNotify = ntfyDict[param[1].TrimStart('+')];
				genNotify.assocMsg = msgDict[param[0]];
			}
#>
	public sealed class <#= param[0] #> : <#= isNotify ? "INotification" : "" #> <#= (isNotify && isResponse) ? "," : "" #> <#= isResponse ? "IResponse" : "" #>
	{
		<#= isNotify ? "public NotificationType NotifyType { get; } = NotificationType." + genNotify.enumName + ";" : "" #>
		<#= isResponse ? "public string ReturnCode { get; set; }" : "" #>
<#
			for(int i = 2; i < param.Length; i++)
			{
				GenField genField;
				if(!fldDict.TryGetValue(param[i], out genField)) { this.Write(Environment.NewLine + "#warning Missing Field: " + param[i]); continue; }
#>
		public <#= genField.fldType #> <#= genField.fldName #> { get; set; }<#
			}
#>

		public void SetField(string name, string value)
		{
<#
			if (param.Length > 2) {#>
			switch(name)
			{
<#
			for(int i = 2; i < param.Length; i++)
			{
				GenField genField;
				if(!fldDict.TryGetValue(param[i], out genField)) { this.Write(Environment.NewLine + "#warning Missing Field: " + param[i]); continue; }
#>
			case "<#= genField.tsName #>": <#= genField.fldName #> = <#= convDict[genField.fldType] #> break;<#
			}
#>
			<#= isNotify ? "" : ("case \"return_code\": ReturnCode = " + convDict["string"] + " break;") #>
			}
<#
			}#>
		}
	}
<#
		}
		else if(parts[0] == "FIELD")
		{
			var param = parts[1].Replace(" ", "").Split(',');
			if(param.Length < 4) { this.Write("#warning Invalid FIELD: " + line); continue; }
			fldDict.Add(param[0], new GenField { tsName=param[1], fldName=param[2], fldType=param[3] } );
		}
		else if(parts[0] == "NOTIFY")
		{
			var param = parts[1].Replace(" ", "").Split(',');
			if(param.Length < 2) { this.Write("#warning Invalid NOTIFY: " + line); continue; }
			ntfyDict.Add(param[0], new GenNotify { enumName=param[1] } );
		}
		else if(parts[0] == "CONV")
		{
			var param = parts[1].Replace(" ", "").Split(new[] { ',' }, 2);
			if(param.Length < 2) { this.Write("#warning Invalid CONV: " + line); continue; }
			convDict.Add(param[0], param[1] );
		}
		else if(parts[0] == "BREAK")
		{
			break;
		}
	}
#>
	public static class MessageHelper
	{
		public static NotificationType GetNotificationType(string name)
		{
			switch(name)
			{
<#
	foreach(var kvp in ntfyDict)
	{
#>
			case "<#= kvp.Key #>": return NotificationType.<#= kvp.Value.enumName #>;<#
	}
#>
			default: return NotificationType.Unknown;
			}
		}

		public static INotification GenerateNotificationType(NotificationType name)
		{
			switch(name)
			{
<#
	foreach(var kvp in ntfyDict)
	{
#>
			<#= kvp.Value.assocMsg == null ? "#warning " : "" #>case NotificationType.<#= kvp.Value.enumName #>: return new <#= kvp.Value.assocMsg?.className ?? "" #>();<#
	}
#>
			case NotificationType.Unknown:
			default: throw Util.UnhandledDefault(name);
			}
		}
	}
}

<#+	class GenField
{
	public string tsName;
	public string fldName;
	public string fldType;
}
class GenMsg
{
	public string className;
	public string ntfyName;
}
class GenNotify
{
	public string enumName;
	public GenMsg assocMsg;
}
#>